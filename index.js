'use strict';

module.exports = {};
module.exports.getMetrics = getMetrics;
module.exports.prepareQueries = prepareQueries;
module.exports.outputMetrics = outputMetrics;
module.exports.elbMetrics = elbMetrics;
var queue = require('d3-queue').queue;
var AWS = module.exports.AWS = require('aws-sdk');

/**
 * Creates parameters for each cloudwatch query given the input from the user.
 * @param {Object} following input from the user - startTime, endTime, region, elbname
 * @param {callback}
 */

function elbMetrics(startTime, endTime, region, elbname, callback) {
    var awsRegions = ['us-east-1', 'us-west-2', 'ap-southeast-1', 'ap-southeast-2', 'ap-northeast-1', 'eu-central-1', 'eu-west-1'];

    if (!awsRegions.indexOf(region) >= 0) {
        return callback(new Error('provided region name not an AWS region'));
    }

    var parameters = {
        startTime: startTime,
        endTime: endTime,
        region: region,
        elbname: elbname
    };

    var queries = prepareQueries(parameters);
    outputMetrics(queries, region, function (err, data) {
        if (err) return callback(err);
        else return callback(null, data);
    });
}
/**
 * Creates parameters for each cloudwatch query given the input from the user.
 * @param {Object} commmand line input formatted into an object
 * @returns {Array} array of desired metric parameters
 */

function prepareQueries(obj) {
    var desiredMetrics = {'HTTPCode_Backend_2XX': 'Sum', 'HTTPCode_Backend_3XX': 'Sum', 'HTTPCode_Backend_4XX': 'Sum', 'HTTPCode_Backend_5XX': 'Sum', 'RequestCount': 'Sum', 'Latency': 'Average'};
    var desiredMetricsParameters = [];
    for (var i in desiredMetrics) {

        var params = {
            EndTime: new Date(obj.endTime).toISOString(),
            MetricName: i,
            Namespace: 'AWS/ELB',
            Period: 60,
            StartTime: new Date(obj.startTime).toISOString(),
            Statistics: [desiredMetrics[i].toString()],
            Dimensions: [
                {
                    Name: 'LoadBalancerName',
                    Value: obj.elbname
                }
            ]
        };
        desiredMetricsParameters.push({parameter: params, region: obj.region});
    }
    return desiredMetricsParameters;
}

/**
 * Queues requests for each parameter and returns a formatted version of the result
 *
 * @param {Array} parameters generated by prepareQueries
 * @param {String} region where the ELB is present
 * @param {callback}
 * @returns {Array} formatted results received from cloudwatch getMetricStatistics
 */

function outputMetrics(desiredMetricsDimensions, region, callback) {
    var q = queue(6);
    var allMetrics = [];
    desiredMetricsDimensions.forEach(function (i) {
        q.defer(getMetrics, i.parameter, i.region);
    });
    q.awaitAll(function (err, data) {
        if (err) return callback(err);
        else {
            data.forEach(function (i) {
                allMetrics.push({Label: i.Label, Datapoints: i.Datapoints});
            });
            callback(null, allMetrics);
        }
    });
}

/**
 * Makes requests to the cloudwatch api and gets Sum/Average for
 * HTTPCode_Backend_2XX, HTTPCode_Backend_3XX, HTTPCode_Backend_4XX, HTTPCode_Backend_5XX, RequestCount, Latency
 *
 * @param {Object} parameter Object for getMetricStatistics
 * @param {String} region where the ELB is present
 * @param {callback}
 * @returns {Object} Datapoints and Labels for the given MetricName in the form of an Object
 */

function getMetrics(params, region, callback) {
    AWS.config.update({region: region});
    var cloudwatch = new AWS.CloudWatch();

    cloudwatch.getMetricStatistics(params, function (err, data) {
        if (err) return callback(err);
        else {
            return callback(null, data);
        }
    });
}
